<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://anshaohan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anshaohan.github.io/"/>
  <updated>2022-10-05T14:28:32.648Z</updated>
  <id>https://anshaohan.github.io/</id>
  
  <author>
    <name>AnShaoHan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>for in 和 for of的区别</title>
    <link href="https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-05T12:26:30.000Z</published>
    <updated>2022-10-05T14:28:32.648Z</updated>
    
    <content type="html"><![CDATA[<p>for in  和 for of 的区别<br>    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的<br>    for in的区别<br>        for in  遍历获取的是对象的键值  而for of 遍历获取的是对象的键名<br>        for in 是遍历整个对象 还有对象的原型链<br>        for of  是只遍历 对象的值 不遍历对象的原型链<br>        对于数组的遍历<br>        for in 会返回数组的可枚举属性 包括原型链的可枚举属性<br>        for of 只会返回数组下标对应的属性值<br>        总结就是 for in 主要是为了遍历对象而生的 不适用遍历数组<br>        而for of 可以遍历数组 字符串 等等的一些仅获取值的对象</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;for in  和 for of 的区别&lt;br&gt;    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的&lt;br&gt;    for in的区别&lt;br&gt;        for in  遍历获取的是对象的键值  而for of 遍历获取的是对象的键名&lt;br&gt;        for in 是遍历整个对象 还有对象的原型链&lt;br&gt;        for of  是只遍历 对象的值 不遍历对象的原型链&lt;br&gt;        对于数组的遍历&lt;br&gt;        for in 会返回数组的可枚举属性 包括原型链的可枚举属性&lt;br&gt;        for of 只会返回数组下标对应的属性值&lt;br&gt;        总结就是 for in 主要是为了遍历对象而生的 不适用遍历数组&lt;br&gt;        而for of 可以遍历数组 字符串 等等的一些仅获取值的对象&lt;/p&gt;
</summary>
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>vue中的diff算法和虚拟dom</title>
    <link href="https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2019-10-20T11:08:13.000Z</published>
    <updated>2022-10-05T11:54:07.511Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新<br>diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实dom<br>diff算法的特性就是 同级比较 深度优先<br>diff算法的原理<br>    首先会有一个 h函数 这个函数中有一个vnode方法 创建虚拟dom 并且返回出去 作用就是初始化时将根据真实dom创建一层虚拟dom<br>    当数据更新时 会创建一个新的虚拟dom 将新的虚拟dom和旧的虚拟dom 传入patch函数中并且进行对比<br>    patch相当于对比入口,对比的是根节点并且将更新操作到真实dom上<br>    patch函数中有几个方法 patchVnode 进行两个节点的子节点进行比较并且将更新操作到真实dom<br>    然后有一个 updataChildren 方法进行对比节点<br>    对比过程中会有四个指针  旧前  旧后  新前  新后 四个指针  旧节点的第一个 和最后一个节点我们称之为 旧前和旧后<br>    相同的 新的vdom 的第一个和最后一个称之为 新前 新后<br>    对比过程<br>        旧前和新前对比    旧后和新后对比  旧前和新后对比 旧后和新前对比<br>    在对比过程中如果对比两个节点相同就不会继续对比 然后继续对比剩下的 如果对比两个节点没有相似度的话就直接新增节点<br>    diff算法就是一个循环递归的过程<br>    具体源码的话可以去看一些 snabbdom 这个库 diff算法是基于这个库的<br>虚拟dom<br>    虚拟dom简单来说就是一个js对象  使用js对象的方式来描述页面的dom<br>    虚拟dom的好处 相比于真实dom 虚拟dom的创建成本比较低 并且如果中间不加一层虚拟dom直接操作真实dom的话会频繁的触发回流和重绘<br>    造成浏览器的资源浪费并且会造成页面卡顿 影响用户体验 如果有一层虚拟dom呢 如果数据更新就会先去操作虚拟dom 等待对比更新完成之后才会操作真实dom 大大的提高了浏览器的效率，真实dom的创建成本很高 哪怕是简单的一个div 也有很多的属性和方法 而虚拟dom的话就只需要最基本的方法就可以实现<br>key的作用<br>    ​key的作用就是唯一标识  在进行diff的时候对比的两个虚拟节点，会进行判断是否为相同节点  ，有了key之后 可以更加明确的判断连哥哥姐弟啊你是否为同一个虚拟节点  是的话就判断子节点是否有变更 如果不加key 的话如果两个标签名相同 就会判定为同一个节点 ，对比之后就会发现两个节点有不一样 这样就会增加很多对真实dom的操作 导致页面频繁的回流和重绘  使用key可以有效的减少真实dom的变动减少页面的回流和重绘 从而提高页面更新的效率 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新&lt;br&gt;diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实d</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 双向数据绑定原理</title>
    <link href="https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2019-08-16T11:09:31.000Z</published>
    <updated>2022-10-05T08:15:01.899Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法</p><p>实现一个简单的数据响应</p><pre><code>Object.defineProperty(obj,&#39;name&#39;,&#123;    get:function()&#123;        // 获取数据        return obj.name    &#125;,    set:function(val)&#123;        // 获取到新的值并且赋值给对象属性        obj.name = val    &#125;&#125;)</code></pre><p>这样就可以实现一个简单的数据响应式<br>当然这是vue2中的数据响应式<br>更新过程<br>    1. new Mvvm()   &#x2F;&#x2F; 创建一个vue实例<br>    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法<br>       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数<br>    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式</p><p>vue2 中的数据响应式的话是有缺点的<br>    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题<br>    比如 对象添加一个属性 为什么这个属性不是响应式的<br>        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性<br>    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到<br>    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式<br>vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式<br>    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象<br>    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应</p><pre><code>new Proxy(obj,&#123;    get:function(target,key,proxy)&#123;  // 三个参数  目标  属性名称  proxy实例本身        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去        return res    &#125;,    set:function(target,key,value,proxy)&#123;  // 四个参数 目标  属性名称 proxy实例本身        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去         return res    &#125;&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;b</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://anshaohan.github.io/2019/02/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://anshaohan.github.io/2019/02/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2019-02-20T02:08:13.000Z</published>
    <updated>2022-10-05T14:15:44.013Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。</p><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含</p><p>JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。<br>CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。<br>资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。</p><p>通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件。</p><h5 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h5><p>正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。规范化指的是我们在工程开发初期以及开发期间制定的系列规范，其中又包含了</p><p>项目目录结构<br>编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。<br>联调规范<br>文件命名规范<br>样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。<br>git flow 工作流：其中包含分支命名规范、代码合并规范等。<br>定期 code review … 等等</p><h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><p>从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些只是前端自动化其中的一部分，前端自动化还包含了持续集成、自动化测试等方方面面。</p><p>以上就是我所了解的前端工程化，以工程的角度去理解我们的web前端。工程是工程，而不是某项技术。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。&lt;/p&gt;
&lt;h5 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h5&gt;&lt;p</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>Css盒子模型</title>
    <link href="https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-02-16T11:09:31.000Z</published>
    <updated>2022-10-05T06:11:58.272Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框）</li></ul><p>盒子总宽度 &#x3D; width + padding + border + margin;</p><p>盒子总高度 &#x3D; height + padding + border + margin</p><p> 也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值 </p><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin</li></ul><p>盒子总宽度 &#x3D; width + margin;</p><p>盒子总高度 &#x3D; height + margin;</p><p> 也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border</code>值 </p><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><ul><li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致</li><li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li><li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;标准盒子模型： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;content（内容）&lt;/li&gt;
&lt;li&gt;margin（外边距） ：盒子与盒子之间的距离。&lt;/li&gt;
&lt;li&gt;padding（内边距）：内容与边框的距离。&lt;/li&gt;
&lt;li&gt;bord</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="https://anshaohan.github.io/2018/12/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://anshaohan.github.io/2018/12/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2018-12-05T14:16:51.000Z</published>
    <updated>2022-10-05T14:25:41.609Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>浅拷贝简单来说 拷贝的是对象再栈中的值 或者引用数据类型的指向内存空间<br>也就是说 浅拷贝的基本数据类型不会互相影响  但是引用数据类型就会进行一个互相影响 源对象发生变化之后 拷贝对象也会跟着变化</p><p>深拷贝就是 拷贝的是对象的整体 并且返回一个新的对象 并且新对象是新开辟一个内存空间 两个对象之间并不会互相影响</p><p>实现深拷贝的一些方法</p><p>循环递归</p><p>function deepclone(obj) {<br>      &#x2F;&#x2F; 判断是什么类型的数据<br>      if (typeof obj !&#x3D;&#x3D; “object” || obj &#x3D;&#x3D; null) return obj;<br>      &#x2F;&#x2F; 定义复制对象<br>      let copy &#x3D; {};<br>      &#x2F;&#x2F; 如果传入的是数组则copy定义为数组<br>      if(obj.constructor&#x3D;&#x3D;Array){<br>        copy &#x3D; []<br>      }<br>      for (key in obj) {<br>        console.log(obj[key]);<br>        &#x2F;&#x2F; deepclone(arr[i])<br>        copy[key] &#x3D; deepclone(obj[key])<br>      }<br>      return copy<br>    }</p><p>使用 JSON 中的  stringfiy 和 parse 方法 来将 对象进行解析成json字符串 然后再解析回来 就可以实现一个深拷贝对象</p><p>使用 loadsh第三方库中的 deepclone 这个方法就可以实现对象的深拷贝</p><p>需要注意的是 es6新增的一个 扩展运算符  当对象是仅一层的时候是 一个深拷贝  超过一层之后就是浅拷贝<br>和扩展运算符差不多的是 object中的 assign这个 方法 也是仅一层时是深拷贝 超过一层就是浅拷贝</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;浅拷贝简单来说 拷贝的是对象再栈中的值 或者引用数据类型的指向内存空间&lt;br&gt;也就是说 浅拷贝的基本数据类型不会互相影响  但是引用数据类型就会进行一个互相影响 源对象发生变化之后 拷贝对象也会跟着变化&lt;/p&gt;
&lt;p&gt;深拷贝</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>webpack 类似的打包工具有哪些？</title>
    <link href="https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-10-05T01:32:19.000Z</published>
    <updated>2022-10-05T06:11:53.222Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多</p><p>​优点  代码更简洁  效率更高   默认支持 tree-shaking</p><p>​缺点就是 加载其他类型的资源文件或者是导入commonjs模块</p><p>​编译es新特性等等一些需求需要使用插件来完成 会使开发效率降低</p><p>​但是在打包js库时 rollup比webpack更有优势  打包代码更小更快</p><p>​parcel  </p><p>​相比于webpack来说用法更简单 支持自动安装依赖，并且不需要配置什么，因为时多线程所以构建速度也会比webpack快，但是无法向webpack一样配置对应的loader</p><p>​snowpack</p><p>​每次保存单个文件时 为应用程序每个文件构建一次，就可以永久缓存 文件更改时 snowpack 会重新构建该文件</p><p>​Vite</p><p>​是一种新型前端构建工具 能显著的提升前端开发体验</p><p>​两部分组成</p><p>​一个开发服务器</p><p>​一套构建指令  使用rollup 来打包你的代码  并且不需要自己配置</p><p>​就可以输出用于生产环境的优化过的静态资源</p><p>​快速的冷启动 、即时的模块热更新 真正的按需编译</p><p>​vite会直接启动开发服务器 不需要进行打包操作 也就意味着不需要分析 模块之间的依赖 不需要编译 所以启动速度很快</p><p>​当修改一个模块时只需要然浏览器重新请求这个模块 不需要像webpack那样需要把该模块的相关依赖全部编译 效率相对来说更高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多&lt;/p&gt;
&lt;p&gt;​			优点  代码更简洁  效率更高   默认支持 tree-shaking</summary>
      
    
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/categories/webpack/"/>
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2018-07-05T03:33:50.000Z</published>
    <updated>2022-10-05T11:07:07.820Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>  防抖和节流简单来说就是个可以处理高频率请求的一种手段</p><pre><code>    防抖         函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。    节流        函数在n秒内执行,如果在n秒内又重复执行该函数,则不会重复执行,直到计时完毕然后运行一次请求。    区别        防抖是在一段时间内如果重复多次的请求 那么只会执行最后一次  相对的场景 比如搜索框  当我们输入完毕之后才会发送请求而不是变一下就会发送一个请求        节流是在一段时间内如果重复多次的请求 那么只会执行最后一次 相对的场景  比如监听滚动条然后让图片进行懒加载     相同点        都可以使用setTimeout 进行实现  目的相同 降低回调 节省计算成本    主要应用场景         防抖             a、scroll事件滚动触发，            b、搜索框输入查询            c、表单验证            d、按钮提交事件            e、浏览器窗口缩放，resize事件        节流            a、DOM元素的拖拽功能实现            b、射击游戏类            c、计算鼠标移动的距离            d、监听scroll事件    防抖实现        function F(fn)&#123;  // 防抖函数            let timeout   // 定义一个参数获取时间            return function()&#123;                clearTimeout(timeout)                timeout = setTimeout(()=&gt;&#123;  // 定义定时器 500毫秒的间隔                     fn.apply(this,arguments)                 &#125;,500)            &#125;        &#125;        每次调用 F 函数 都会清除之前的timeout  并且返回一个新的timeout setTimeout 设置的时间结束后才会运行原本的函数，这样就是一个简单的函数防抖实现    节流实现   有两种方法可以实现  定时器  或者 时间戳的方式        function J(fn, wait)&#123;           // 时间戳版            let previous = 0;            return function () &#123;                let now = new Date();                if (now - previous &gt; wait) &#123;                    previous = now;                    func.apply(this, arguments)                &#125;            &#125;        &#125;        定义时间戳然后返回一个函数 函数内部声明一个执行时的时间戳 然后进行判断 当前时间减去定义的时间戳如果大于传入的等待时间那就把定义的时间戳赋值到刚刚创建的新的时间戳 并且执行函数         function J(fn, wait) &#123;            // 定时器版            let timer;            return function () &#123;                let context = this;                if (!timer) &#123;                    timer = setTimeout(() =&gt; &#123;                        timer = null;                        func.apply(context, arguments)                    &#125;, wait)                &#125;            &#125;        &#125;        定时器版本 就是增加一个setTimeout实现  定义一个空变量 然后 返回函数 函数中获取到当前的this 然后进行判断这个定义的变量是否存在 不存在就时false 然后取反值 然后将setTimeout 赋值给定义的变量然后再定时器内部将这个变量释放 并且执行传入的函数</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;  防抖和节流简单来说就是个可以处理高频率请求的一种手段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    防抖 
        函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。
  </summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>HTML5新增的特性和标签</title>
    <link href="https://anshaohan.github.io/2018/05/22/HTML5%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E6%A0%87%E7%AD%BE/"/>
    <id>https://anshaohan.github.io/2018/05/22/HTML5%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E6%A0%87%E7%AD%BE/</id>
    <published>2018-05-22T04:08:13.000Z</published>
    <updated>2022-10-05T14:13:26.017Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><pre><code>   HTML5新增        标签新增了一套页面布局的标签            &lt;header&gt;头部&lt;/header&gt;            &lt;nav&gt;导航&lt;/nav&gt;            &lt;main&gt;内容&lt;/main&gt;            &lt;asdie&gt;侧边栏&lt;/asdie&gt;            &lt;footer&gt;底部&lt;/footer&gt;            &lt;article&gt;博客 文章 帖子等&lt;/article&gt;            &lt;section&gt;章节 独立的一块 相当于无语义的div&lt;section&gt;            &lt;video&gt;视频&lt;/video&gt;            &lt;audio&gt;音频&lt;/audio&gt;            &lt;figure&gt;用于对元素组合 多用于图片和图片描述&lt;/figure&gt;            &lt;mark&gt;主要用来在视觉上向用户呈现那些需要突出的文字&lt;/mark&gt;            &lt;details&gt;描述&lt;summary&gt;描述的标题&lt;/summary&gt;&lt;/details&gt;            &lt;meter&gt;进度条&lt;/meter&gt;            &lt;progress&gt;也可以理解为 进度条&lt;/progress&gt;                &lt;datalist&gt;下拉框&lt;option&gt;item&lt;/option&gt;&lt;/datalist&gt;             &lt;canvas&gt;画布&lt;/canvas&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;   HTML5新增
        标签新增了一套页面布局的标签
            &amp;lt;header&amp;gt;头部&amp;lt;/header&amp;gt;
            &amp;lt;nav&amp;gt;导航&amp;l</summary>
      
    
    
    
    <category term="HTML" scheme="https://anshaohan.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://anshaohan.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>
