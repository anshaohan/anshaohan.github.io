<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://anshaohan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anshaohan.github.io/"/>
  <updated>2022-10-05T03:37:59.522Z</updated>
  <id>https://anshaohan.github.io/</id>
  
  <author>
    <name>AnShaoHan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://anshaohan.github.io/2022/10/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://anshaohan.github.io/2022/10/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2022-10-05T03:33:50.000Z</published>
    <updated>2022-10-05T03:37:59.522Z</updated>
    
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js - 防抖和节流" scheme="https://anshaohan.github.io/tags/Js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue 双向数据绑定原理</title>
    <link href="https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2019-08-16T11:09:31.000Z</published>
    <updated>2022-10-05T03:25:24.917Z</updated>
    
    <content type="html"><![CDATA[<p>双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法</p><p>实现一个简单的数据响应</p><p>Object.defineProperty(obj,’name’,{<br>    get:function(){<br>        &#x2F;&#x2F; 获取数据<br>        return obj.name<br>    },<br>    set:function(val){<br>        &#x2F;&#x2F; 获取到新的值并且赋值给对象属性<br>        obj.name &#x3D; val<br>    }<br>})</p><p>这样就可以实现一个简单的数据响应式<br>当然这是vue2中的数据响应式<br>更新过程<br>    1. new Mvvm()   &#x2F;&#x2F; 创建一个vue实例<br>    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法<br>       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数<br>    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式</p><p>vue2 中的数据响应式的话是有缺点的<br>    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题<br>    比如 对象添加一个属性 为什么这个属性不是响应式的<br>        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性<br>    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到<br>    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式<br>vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式<br>    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象<br>    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应</p><pre><code>new Proxy(obj,&#123;    get:function(target,key,proxy)&#123;  // 三个参数  目标  属性名称  proxy实例本身        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去        return res    &#125;,    set:function(target,key,value,proxy)&#123;  // 四个参数 目标  属性名称 proxy实例本身        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去         return res    &#125;&#125;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;br&gt;其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法&lt;/p&gt;
&lt;p&gt;实现一个简单的数据响应&lt;/p&gt;
&lt;p&gt;Object.defineProperty(obj,’name’,{&lt;br&gt;    get:function(){&lt;br&gt;        &amp;#x2F;&amp;#x2F; 获取数据&lt;br&gt;        return obj.name&lt;br&gt;    },&lt;br&gt;    set:function(val){&lt;br&gt;        &amp;#x2F;&amp;#x2F; 获取到新的值并且赋值给对象属性&lt;br&gt;        obj.name &amp;#x3D; val&lt;br&gt;    }&lt;br&gt;})&lt;/p&gt;
&lt;p&gt;这样就可以实现一个简单的数据响应式&lt;br&gt;当然这是vue2中的数据响应式&lt;br&gt;更新过程&lt;br&gt;    1. new Mvvm()   &amp;#x2F;&amp;#x2F; 创建一个vue实例&lt;br&gt;    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法&lt;br&gt;       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数&lt;br&gt;    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式&lt;/p&gt;
&lt;p&gt;vue2 中的数据响应式的话是有缺点的&lt;br&gt;    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题&lt;br&gt;    比如 对象添加一个属性 为什么这个属性不是响应式的&lt;br&gt;        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性&lt;br&gt;    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到&lt;br&gt;    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式&lt;br&gt;vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式&lt;br&gt;    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象&lt;br&gt;    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Proxy(obj,&amp;#123;
    get:function(target,key,proxy)&amp;#123;  // 三个参数  目标  属性名称  proxy实例本身
        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去
        return res
    &amp;#125;,
    set:function(target,key,value,proxy)&amp;#123;  // 四个参数 目标  属性名称 proxy实例本身
        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去 
        return res
    &amp;#125;
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Css盒子模型</title>
    <link href="https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-02-16T11:09:31.000Z</published>
    <updated>2022-10-05T01:37:12.847Z</updated>
    
    <content type="html"><![CDATA[<p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框）</li></ul><p>盒子总宽度 &#x3D; width + padding + border + margin;</p><p>盒子总高度 &#x3D; height + padding + border + margin</p><p> 也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值 </p><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin</li></ul><p>盒子总宽度 &#x3D; width + margin;</p><p>盒子总高度 &#x3D; height + margin;</p><p> 也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border</code>值 </p><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><ul><li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致</li><li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li><li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;标准盒子模型： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;content（内容）&lt;/li&gt;
&lt;li&gt;margin（外边距） ：盒子与盒子之间的距离。&lt;/li&gt;
&lt;li&gt;padding（内边距）：内容与边框的距离。&lt;/li&gt;
&lt;li&gt;border（边框）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;盒子总宽度 &amp;#x3D; width + padding + border + margin;&lt;/p&gt;
&lt;p&gt;盒子总高度 &amp;#x3D; height + padding + border + margin&lt;/p&gt;
&lt;p&gt; 也就是，&lt;code&gt;width/height&lt;/code&gt; 只是内容高度，不包含 &lt;code&gt;padding&lt;/code&gt; 和 &lt;code&gt;border&lt;/code&gt;值 &lt;/p&gt;
&lt;p&gt;IE盒子模型（怪异盒模型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;content &lt;/li&gt;
&lt;li&gt;margin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;盒子总宽度 &amp;#x3D; width + margin;&lt;/p&gt;
&lt;p&gt;盒子总高度 &amp;#x3D; height + margin;&lt;/p&gt;
&lt;p&gt; 也就是，&lt;code&gt;width/height&lt;/code&gt; 包含了 &lt;code&gt;padding&lt;/code&gt;和 &lt;code&gt;border&lt;/code&gt;值 &lt;/p&gt;</summary>
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>webpack 类似的打包工具有哪些？</title>
    <link href="https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-10-05T01:32:19.000Z</published>
    <updated>2022-10-05T01:37:37.824Z</updated>
    
    <content type="html"><![CDATA[<p>​rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多</p><p>​优点  代码更简洁  效率更高   默认支持 tree-shaking</p><p>​缺点就是 加载其他类型的资源文件或者是导入commonjs模块</p><p>​编译es新特性等等一些需求需要使用插件来完成 会使开发效率降低</p><p>​但是在打包js库时 rollup比webpack更有优势  打包代码更小更快</p><p>​parcel  </p><p>​相比于webpack来说用法更简单 支持自动安装依赖，并且不需要配置什么，因为时多线程所以构建速度也会比webpack快，但是无法向webpack一样配置对应的loader</p><p>​snowpack</p><p>​每次保存单个文件时 为应用程序每个文件构建一次，就可以永久缓存 文件更改时 snowpack 会重新构建该文件</p><p>​Vite</p><p>​是一种新型前端构建工具 能显著的提升前端开发体验</p><p>​两部分组成</p><p>​一个开发服务器</p><p>​一套构建指令  使用rollup 来打包你的代码  并且不需要自己配置</p><p>​就可以输出用于生产环境的优化过的静态资源</p><p>​快速的冷启动 、即时的模块热更新 真正的按需编译</p><p>​vite会直接启动开发服务器 不需要进行打包操作 也就意味着不需要分析 模块之间的依赖 不需要编译 所以启动速度很快</p><p>​当修改一个模块时只需要然浏览器重新请求这个模块 不需要像webpack那样需要把该模块的相关依赖全部编译 效率相对来说更高</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多&lt;/p&gt;
&lt;p&gt;​			优点  代码更简洁  效率更高   默认支持 tree-shaking&lt;/p&gt;
&lt;p&gt;​			缺点就是 加载其他类型的资源文件或者是导入commonjs模块&lt;/p&gt;
&lt;p&gt;​			编译es新特性等等一些需求需要使用插件来完成 会使开发效率降低&lt;/p&gt;
&lt;p&gt;​			但是在打包js库时 rollup比webpack更有优势  打包代码更小更快&lt;/p&gt;
&lt;p&gt;​		parcel  &lt;/p&gt;
&lt;p&gt;​			相比于webpack来说用法更简单 支持自动安装依赖，并且不需要配置什么，因为时多线程所以构建速度也会比webpack快，但是无法向webpack一样配置对应的loader&lt;/p&gt;
&lt;p&gt;​		snowpack&lt;/p&gt;
&lt;p&gt;​				每次保存单个文件时 为应用程序每个文件构建一次，就可以永久缓存 文件更改时 snowpack 会重新构建该文件&lt;/p&gt;
&lt;p&gt;​		Vite&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/categories/webpack/"/>
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
