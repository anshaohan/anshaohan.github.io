<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://anshaohan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anshaohan.github.io/"/>
  <updated>2022-10-05T11:49:29.238Z</updated>
  <id>https://anshaohan.github.io/</id>
  
  <author>
    <name>AnShaoHan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中的diff算法和虚拟dom</title>
    <link href="https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2019-10-20T11:08:13.000Z</published>
    <updated>2022-10-05T11:49:29.238Z</updated>
    
    <content type="html"><![CDATA[<pre><code>diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实domdiff算法的特性就是 同级比较 深度优先diff算法的原理        首先会有一个 h函数 这个函数中有一个vnode方法 创建虚拟dom 并且返回出去 作用就是初始化时将根据真实dom创建一层虚拟dom        当数据更新时 会创建一个新的虚拟dom 将新的虚拟dom和旧的虚拟dom 传入patch函数中并且进行对比        patch相当于对比入口,对比的是根节点并且将更新操作到真实dom上        patch函数中有几个方法 patchVnode 进行两个节点的子节点进行比较并且将更新操作到真实dom        然后有一个 updataChildren 方法进行对比节点        对比过程中会有四个指针  旧前  旧后  新前  新后 四个指针  旧节点的第一个 和最后一个节点我们称之为 旧前和旧后        相同的 新的vdom 的第一个和最后一个称之为 新前 新后        对比过程              旧前和新前对比    旧后和新后对比  旧前和新后对比 旧后和新前对比        在对比过程中如果对比两个节点相同就不会继续对比 然后继续对比剩下的 如果对比两个节点没有相似度的话就直接新增节点        diff算法就是一个循环递归的过程        具体源码的话可以去看一些 snabbdom 这个库 diff算法是基于这个库的虚拟dom         虚拟dom简单来说就是一个js对象  使用js对象的方式来描述页面的dom        虚拟dom的好处 相比于真实dom 虚拟dom的创建成本比较低 并且如果中间不加一层虚拟dom直接操作真实dom的话会频繁的触发回流和重绘        造成浏览器的资源浪费并且会造成页面卡顿 影响用户体验 如果有一层虚拟dom呢 如果数据更新就会先去操作虚拟dom 等待对比更新完成之后才会操作真实dom 大大的提高了浏览器的效率，真实dom的创建成本很高 哪怕是简单的一个div 也有很多的属性和方法 而虚拟dom的话就只需要最基本的方法就可以实现key的作用        ​key的作用就是唯一标识  在进行diff的时候对比的两个虚拟节点，会进行判断是否为相同节点  ，有了key之后 可以更加明确的判断连哥哥姐弟啊你是否为同一个虚拟节点  是的话就判断子节点是否有变更 如果不加key 的话如果两个标签名相同 就会判定为同一个节点 ，对比之后就会发现两个节点有不一样 这样就会增加很多对真实dom的操作 导致页面频繁的回流和重绘  使用key可以有效的减少真实dom的变动减少页面的回流和重绘 从而提高页面更新的效率         </code></pre>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新
diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实dom
diff算法的特性就是 同级比较 深度优先
diff算法的原理
        首先会有一个 h函数 这个函数中有一个vnode方法 创建虚拟dom 并且返回出去 作用就是初始化时将根据真实dom创建一层虚拟dom
        当数据更新时 会创建一个新的虚拟dom 将新的虚拟dom和旧的虚拟dom 传入patch函数中并且进行对比
        patch相当于对比入口,对比的是根节点并且将更新操作到真实dom上
        patch函数中有几个方法 patchVnode 进行两个节点的子节点进行比较并且将更新操作到真实dom
        然后有一个 updataChildren 方法进行对比节点
        对比过程中会有四个指针  旧前  旧后  新前  新后 四个指针  旧节点的第一个 和最后一个节点我们称之为 旧前和旧后
        相同的 新的vdom 的第一个和最后一个称之为 新前 新后
        对比过程  
            旧前和新前对比    旧后和新后对比  旧前和新后对比 旧后和新前对比
        在对比过程中如果对比两个节点相同就不会继续对比 然后继续对比剩下的 如果对比两个节点没有相似度的话就直接新增节点
        diff算法就是一个循环递归的过程
        具体源码的话可以去看一些 snabbdom 这个库 diff算法是基于这个库的

虚拟dom 
        虚拟dom简单来说就是一个js对象  使用js对象的方式来描述页面的dom
        虚拟dom的好处 相比于真实dom 虚拟dom的创建成本比较低 并且如果中间不加一层虚拟dom直接操作真实dom的话会频繁的触发回流和重绘
        造成浏览器的资源浪费并且会造成页面卡顿 影响用户体验 如果有一层虚拟dom呢 如果数据更新就会先去操作虚拟dom 等待对比更新完成之后才会操作真实dom 大大的提高了浏览器的效率，真实dom的创建成本很高 哪怕是简单的一个div 也有很多的属性和方法 而虚拟dom的话就只需要最基本的方法就可以实现


key的作用 
       ​key的作用就是唯一标识  在进行diff的时候对比的两个虚拟节点，会进行判断是否为相同节点  ，有了key之后 可以更加明确的判断连哥哥姐弟啊你是否为同一个虚拟节点  是的话就判断子节点是否有变更 如果不加key 的话如果两个标签名相同 就会判定为同一个节点 ，对比之后就会发现两个节点有不一样 这样就会增加很多对真实dom的操作 导致页面频繁的回流和重绘  使用key可以有效的减少真实dom的变动减少页面的回流和重绘 从而提高页面更新的效率 


        
&lt;/code&gt;&lt;/pre&gt;
</summary>
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 双向数据绑定原理</title>
    <link href="https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2019-08-16T11:09:31.000Z</published>
    <updated>2022-10-05T08:15:01.899Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法</p><p>实现一个简单的数据响应</p><pre><code>Object.defineProperty(obj,&#39;name&#39;,&#123;    get:function()&#123;        // 获取数据        return obj.name    &#125;,    set:function(val)&#123;        // 获取到新的值并且赋值给对象属性        obj.name = val    &#125;&#125;)</code></pre><p>这样就可以实现一个简单的数据响应式<br>当然这是vue2中的数据响应式<br>更新过程<br>    1. new Mvvm()   &#x2F;&#x2F; 创建一个vue实例<br>    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法<br>       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数<br>    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式</p><p>vue2 中的数据响应式的话是有缺点的<br>    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题<br>    比如 对象添加一个属性 为什么这个属性不是响应式的<br>        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性<br>    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到<br>    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式<br>vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式<br>    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象<br>    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应</p><pre><code>new Proxy(obj,&#123;    get:function(target,key,proxy)&#123;  // 三个参数  目标  属性名称  proxy实例本身        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去        return res    &#125;,    set:function(target,key,value,proxy)&#123;  // 四个参数 目标  属性名称 proxy实例本身        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去         return res    &#125;&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;b</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Css盒子模型</title>
    <link href="https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-02-16T11:09:31.000Z</published>
    <updated>2022-10-05T06:11:58.272Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框）</li></ul><p>盒子总宽度 &#x3D; width + padding + border + margin;</p><p>盒子总高度 &#x3D; height + padding + border + margin</p><p> 也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值 </p><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin</li></ul><p>盒子总宽度 &#x3D; width + margin;</p><p>盒子总高度 &#x3D; height + margin;</p><p> 也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border</code>值 </p><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><ul><li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致</li><li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li><li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;标准盒子模型： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;content（内容）&lt;/li&gt;
&lt;li&gt;margin（外边距） ：盒子与盒子之间的距离。&lt;/li&gt;
&lt;li&gt;padding（内边距）：内容与边框的距离。&lt;/li&gt;
&lt;li&gt;bord</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>webpack 类似的打包工具有哪些？</title>
    <link href="https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-10-05T01:32:19.000Z</published>
    <updated>2022-10-05T06:11:53.222Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多</p><p>​优点  代码更简洁  效率更高   默认支持 tree-shaking</p><p>​缺点就是 加载其他类型的资源文件或者是导入commonjs模块</p><p>​编译es新特性等等一些需求需要使用插件来完成 会使开发效率降低</p><p>​但是在打包js库时 rollup比webpack更有优势  打包代码更小更快</p><p>​parcel  </p><p>​相比于webpack来说用法更简单 支持自动安装依赖，并且不需要配置什么，因为时多线程所以构建速度也会比webpack快，但是无法向webpack一样配置对应的loader</p><p>​snowpack</p><p>​每次保存单个文件时 为应用程序每个文件构建一次，就可以永久缓存 文件更改时 snowpack 会重新构建该文件</p><p>​Vite</p><p>​是一种新型前端构建工具 能显著的提升前端开发体验</p><p>​两部分组成</p><p>​一个开发服务器</p><p>​一套构建指令  使用rollup 来打包你的代码  并且不需要自己配置</p><p>​就可以输出用于生产环境的优化过的静态资源</p><p>​快速的冷启动 、即时的模块热更新 真正的按需编译</p><p>​vite会直接启动开发服务器 不需要进行打包操作 也就意味着不需要分析 模块之间的依赖 不需要编译 所以启动速度很快</p><p>​当修改一个模块时只需要然浏览器重新请求这个模块 不需要像webpack那样需要把该模块的相关依赖全部编译 效率相对来说更高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多&lt;/p&gt;
&lt;p&gt;​			优点  代码更简洁  效率更高   默认支持 tree-shaking</summary>
      
    
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/categories/webpack/"/>
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2018-07-05T03:33:50.000Z</published>
    <updated>2022-10-05T11:07:07.820Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>  防抖和节流简单来说就是个可以处理高频率请求的一种手段</p><pre><code>    防抖         函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。    节流        函数在n秒内执行,如果在n秒内又重复执行该函数,则不会重复执行,直到计时完毕然后运行一次请求。    区别        防抖是在一段时间内如果重复多次的请求 那么只会执行最后一次  相对的场景 比如搜索框  当我们输入完毕之后才会发送请求而不是变一下就会发送一个请求        节流是在一段时间内如果重复多次的请求 那么只会执行最后一次 相对的场景  比如监听滚动条然后让图片进行懒加载     相同点        都可以使用setTimeout 进行实现  目的相同 降低回调 节省计算成本    主要应用场景         防抖             a、scroll事件滚动触发，            b、搜索框输入查询            c、表单验证            d、按钮提交事件            e、浏览器窗口缩放，resize事件        节流            a、DOM元素的拖拽功能实现            b、射击游戏类            c、计算鼠标移动的距离            d、监听scroll事件    防抖实现        function F(fn)&#123;  // 防抖函数            let timeout   // 定义一个参数获取时间            return function()&#123;                clearTimeout(timeout)                timeout = setTimeout(()=&gt;&#123;  // 定义定时器 500毫秒的间隔                     fn.apply(this,arguments)                 &#125;,500)            &#125;        &#125;        每次调用 F 函数 都会清除之前的timeout  并且返回一个新的timeout setTimeout 设置的时间结束后才会运行原本的函数，这样就是一个简单的函数防抖实现    节流实现   有两种方法可以实现  定时器  或者 时间戳的方式        function J(fn, wait)&#123;           // 时间戳版            let previous = 0;            return function () &#123;                let now = new Date();                if (now - previous &gt; wait) &#123;                    previous = now;                    func.apply(this, arguments)                &#125;            &#125;        &#125;        定义时间戳然后返回一个函数 函数内部声明一个执行时的时间戳 然后进行判断 当前时间减去定义的时间戳如果大于传入的等待时间那就把定义的时间戳赋值到刚刚创建的新的时间戳 并且执行函数         function J(fn, wait) &#123;            // 定时器版            let timer;            return function () &#123;                let context = this;                if (!timer) &#123;                    timer = setTimeout(() =&gt; &#123;                        timer = null;                        func.apply(context, arguments)                    &#125;, wait)                &#125;            &#125;        &#125;        定时器版本 就是增加一个setTimeout实现  定义一个空变量 然后 返回函数 函数中获取到当前的this 然后进行判断这个定义的变量是否存在 不存在就时false 然后取反值 然后将setTimeout 赋值给定义的变量然后再定时器内部将这个变量释放 并且执行传入的函数</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;  防抖和节流简单来说就是个可以处理高频率请求的一种手段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    防抖 
        函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。
  </summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
</feed>
