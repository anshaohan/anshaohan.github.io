<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://anshaohan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anshaohan.github.io/"/>
  <updated>2022-10-06T02:28:33.156Z</updated>
  <id>https://anshaohan.github.io/</id>
  
  <author>
    <name>AnShaoHan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何通过js判断一个数组</title>
    <link href="https://anshaohan.github.io/2022/10/06/%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/"/>
    <id>https://anshaohan.github.io/2022/10/06/%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</id>
    <published>2022-10-06T02:28:03.000Z</published>
    <updated>2022-10-06T02:28:33.156Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​<strong>通过原型链判断</strong></p><p>​__ proto __</p><p>​实例的__ proto__属性指向其构造函数的原型对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​constructor</p><p>​实例的constructor属性指向构造函数本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">constructor</span> === <span class="title class_">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​instanceof</p><p>​instanceof可以判断Array是否是实例的构造函数（在原型链上即可）</p><p>​isPrototypeOf()</p><p>​判断Array的原型对象是否为在某个对象的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(arr) )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​通过Object原型上的方法判断</p><p>​Array.isArray()</p><p>​es6中用于判断数组类型的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​Object.prototype.toString</p><p>​Object原型对象上的方法，被所有对象继承，返回<code>&#39;[Object type]&#39;</code>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr))  <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	&lt;strong&gt;通过原型链判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​						__ proto __&lt;/p&gt;
&lt;p&gt;​								实例的__ proto__属性指向其构造函数的原型对象.&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>什么是响应式设计</title>
    <link href="https://anshaohan.github.io/2021/08/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://anshaohan.github.io/2021/08/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-08-16T02:08:50.000Z</published>
    <updated>2022-10-06T02:24:34.901Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>响应式设计是一种网络页面设计布局 页面的开发和设计 应该根据用户的行为和设备大小 来做出相应的响应和调整</p><p>​响应式网站常见的特点：</p><p>​同时适配pc+平板+手机等</p><p>​标签导航在接近手持终端设备时改变为经典的抽屉式导航</p><p>​网站的布局会根据视口来调整模块的大小和位置</p><p>​实现方式</p><p>​原理  通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport</p><p>​实现响应式布局方式</p><p>​媒体查询</p><p>​给不同分辨率的设备编写不同的样式来实现响应式布局，可以给不同分辨率的屏幕设置不同的样式</p><p>​百分比</p><p>​通过百分比单位来实现响应式的效果</p><p>​可以让组件随着浏览器的宽度和高度变化而变化从而实现响应式布局，有些元素并不继承父元素的尺寸 所以并不建议使用百分比实现响应式</p><p>​vw&#x2F;vh</p><p>​vw表示相对于视图窗口的宽度，vh表示相对于视图窗口的高度，任意层级元素，在使用vw单位的情况下。1vw都等于视图宽度的百分之一</p><p>​rem</p><p>​rem 相当于根元素html的font-size属性，默认浏览器字体大小为16px 所以 1rem &#x3D; 16px</p><p>​还可以利用ui框架 的栅格布局实现响应式</p><p>​响应式设计通常会从以下几个方面思考：</p><p>​弹性盒子 和媒体查询等技术</p><p>​使用百分比布局创建流式布局的弹性ui同时使用媒体查询限制元素的尺寸和内容变更范围</p><p>​使用相对单位使得内容自适应调节</p><p>​选择断点针对不同断点实现不同的布局和内容展示</p><p>​总结</p><p>​响应式布局的优点</p><p>​面对不同分辨率设备灵活性强</p><p>​能够快捷解决多设备显示适应问题</p><p>​缺点</p><p>​仅适用布局、信息、框架、并不复杂的部门类型网站</p><p>​兼容各种设备工作量大，效率低下</p><p>​代码累赘，会出现隐藏无用的元素，加载时间加长</p><p>​一种折中性的设计解决方案，多方面因素影响而达不到最佳效果，</p><p>​一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;响应式设计是一种网络页面设计布局 页面的开发和设计 应该根据用户的行为和设备大小 来做出相应的响应和调整&lt;/p&gt;
&lt;p&gt;​						响应式网站常见的特点：&lt;/p&gt;
&lt;p&gt;​									同时适配pc+平板+手机等&lt;/p&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>js中变量提升</title>
    <link href="https://anshaohan.github.io/2020/11/06/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://anshaohan.github.io/2020/11/06/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2020-11-06T03:05:26.000Z</published>
    <updated>2022-10-06T05:34:33.369Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>js中变量提升概念<br>    在js中如果我们进行先调用 后声明赋值的方式进行使用变量 js中的变量提升就会展现出来<br>    当我们先调用这个变量的时候   这个变量隐式的声明 并且赋值为undefined<br>    然后当我们在下面调用这个变量进行赋值时 就会盖过undefined 变成赋值的那个值</p><pre><code>console.log(num)  //这时会打印出 undefinedvar num = 123 //  这是个赋值过程console.log(num) // 打印 123需要注意的是 变量提升只能使用 var  定义  使用es6新增的let  const的话会之间报错</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;js中变量提升概念&lt;br&gt;    在js中如果我们进行先调用 后声明赋值的方式进行使用变量 js中的变量提升就会展现出来&lt;br&gt;    当我们先调用这个变量的时候   这个变量隐式的声明 并且赋值为undefined&lt;br&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>BFC布局</title>
    <link href="https://anshaohan.github.io/2020/09/06/BFC/"/>
    <id>https://anshaohan.github.io/2020/09/06/BFC/</id>
    <published>2020-09-06T06:32:46.000Z</published>
    <updated>2022-10-06T06:56:15.653Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>官方定义：BFC（Block Formatting Context）块格式化上下文， 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。<br>简单来说 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素<br>BFC的应用<br>    1、自适应两栏布局<br>    2、清除内部浮动<br>    3、防止margin上下重叠</p><p>BFC的布局规则<br>    1、内部的Box会在垂直方向，一个接一个地放置。<br>    2、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置）<br>    3、每个元素的margin box的左边， 与包含块border box的左边相接触<br>    4、BFC的区域不会与float box重叠。<br>    5、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>    6、计算BFC的高度时，浮动元素也参与计算</p><p>如何创建一个BFC<br>    使用浮动元素 给盒子设置 float  left 或者 right 就可以打开BFC<br>    使用定位 position  设置 absolute绝对定位 或者 fixed 固定定位<br>    display 设置为 inline-block  table-cell flex inline-flex  table-caption<br>    overflow 不为visible</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;官方定义：BFC（Block Formatting Context）块格式化上下文， 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。&lt;br&gt;简单来说 BFC就是页面上的一</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>typeof 与 instanceof 区别</title>
    <link href="https://anshaohan.github.io/2020/04/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/04/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/</id>
    <published>2020-04-26T11:58:04.000Z</published>
    <updated>2022-10-06T03:47:23.395Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p> typeof 只有6种返回值  number  string   Boolean  object  function undefined</p><p>​typeof 操作符返回一个字符串,表示未经计算的操作数的类型</p><p>虽然 typeof null 为 object  这是javaScript 一个悠久的Bug 不代表null 就是引用数据类型 并且null 本身也不是对象 所以 null在typeof之后返回的是有问题的结果</p><p>​instanceof  运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>​实现原理 顺着原型链去找,直到找到相同的原型对象,返回true , 否则为 false</p><p>​  typeof 与 instanceof 都是判断数据类型的方法 区别如下</p><p>​typeof 会返回一个变量的基本类型,instanceof,返回的是一个布尔值</p><p>​instanceof 可以准确地判断复杂引用数据类型,但是不能正确判断基础数据类型</p><p>​typeof 也存在弊端 虽然可以判断基础数据类型 null除外</p><p>​但是引用数据类型中,除了function 类型以外,其他的也无法判断</p><p>​如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]”</code>的字符串</p><p>typeof 的原理<br>    typeof 是根据二进制来判断的  所以之只能判断基本类型和object 但是并不能判断出是哪一种object<br>    000 对象  010 浮点数  1整数  110 布尔值 100字符串<br>    至于为什么判断null 为object  是因为null的机器码是000 所以会判断为object</p><p>instanceof 原理<br>    就是根据判断对象A是否在对象B的原型链上 如果在那么就会返回True 如果不在就返回False</p><pre><code>简单的实现一个instanceoffunction Myinstance(left,right)&#123; // 接收两个对象    let proto = Object.getPrototyepOf(left)   // 获取到对象的原型    let prototype = right.prototype  // 获取到构造函数的原型    whlie(true)&#123;        // 因为最后会获取到null null是原型的顶层 并且不是一个对象所以会报错 null转换布尔值会是false        // 而对象转换布尔值为 true          if(!proto) return false         if(proto==prototype) return true   // 判断原型和原型是否相同 是的话就返回true        // 如果当前没有找到 就重新赋值往原型链上寻找        proto = Object.getPrototyepOf(proto)    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;p&gt; typeof 只有6种返回值  number  string   Boolean  object  function undefined&lt;/p&gt;
&lt;p&gt;​							typeof 操作符返回一个字符串,表示未经计算的</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>for in 和 for of的区别</title>
    <link href="https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-05T12:26:30.000Z</published>
    <updated>2022-10-05T14:31:07.485Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>for in  和 for of 的区别<br>    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的<br>    for in的区别<br>        for in  遍历获取的是对象的键值  而for of 遍历获取的是对象的键名<br>        for in 是遍历整个对象 还有对象的原型链<br>        for of  是只遍历 对象的值 不遍历对象的原型链<br>        对于数组的遍历<br>        for in 会返回数组的可枚举属性 包括原型链的可枚举属性<br>        for of 只会返回数组下标对应的属性值<br>        总结就是 for in 主要是为了遍历对象而生的 不适用遍历数组<br>        而for of 可以遍历数组 字符串 等等的一些仅获取值的对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;for in  和 for of 的区别&lt;br&gt;    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的&lt;br&gt;    for in的区别&lt;br&gt;        for in  遍</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>js模块化开发是什么</title>
    <link href="https://anshaohan.github.io/2020/01/22/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://anshaohan.github.io/2020/01/22/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-01-22T03:05:51.000Z</published>
    <updated>2022-10-06T05:35:11.961Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>vue中的diff算法和虚拟dom</title>
    <link href="https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2019-10-20T11:08:13.000Z</published>
    <updated>2022-10-05T11:54:07.511Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新<br>diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实dom<br>diff算法的特性就是 同级比较 深度优先<br>diff算法的原理<br>    首先会有一个 h函数 这个函数中有一个vnode方法 创建虚拟dom 并且返回出去 作用就是初始化时将根据真实dom创建一层虚拟dom<br>    当数据更新时 会创建一个新的虚拟dom 将新的虚拟dom和旧的虚拟dom 传入patch函数中并且进行对比<br>    patch相当于对比入口,对比的是根节点并且将更新操作到真实dom上<br>    patch函数中有几个方法 patchVnode 进行两个节点的子节点进行比较并且将更新操作到真实dom<br>    然后有一个 updataChildren 方法进行对比节点<br>    对比过程中会有四个指针  旧前  旧后  新前  新后 四个指针  旧节点的第一个 和最后一个节点我们称之为 旧前和旧后<br>    相同的 新的vdom 的第一个和最后一个称之为 新前 新后<br>    对比过程<br>        旧前和新前对比    旧后和新后对比  旧前和新后对比 旧后和新前对比<br>    在对比过程中如果对比两个节点相同就不会继续对比 然后继续对比剩下的 如果对比两个节点没有相似度的话就直接新增节点<br>    diff算法就是一个循环递归的过程<br>    具体源码的话可以去看一些 snabbdom 这个库 diff算法是基于这个库的<br>虚拟dom<br>    虚拟dom简单来说就是一个js对象  使用js对象的方式来描述页面的dom<br>    虚拟dom的好处 相比于真实dom 虚拟dom的创建成本比较低 并且如果中间不加一层虚拟dom直接操作真实dom的话会频繁的触发回流和重绘<br>    造成浏览器的资源浪费并且会造成页面卡顿 影响用户体验 如果有一层虚拟dom呢 如果数据更新就会先去操作虚拟dom 等待对比更新完成之后才会操作真实dom 大大的提高了浏览器的效率，真实dom的创建成本很高 哪怕是简单的一个div 也有很多的属性和方法 而虚拟dom的话就只需要最基本的方法就可以实现<br>key的作用<br>    ​key的作用就是唯一标识  在进行diff的时候对比的两个虚拟节点，会进行判断是否为相同节点  ，有了key之后 可以更加明确的判断连哥哥姐弟啊你是否为同一个虚拟节点  是的话就判断子节点是否有变更 如果不加key 的话如果两个标签名相同 就会判定为同一个节点 ，对比之后就会发现两个节点有不一样 这样就会增加很多对真实dom的操作 导致页面频繁的回流和重绘  使用key可以有效的减少真实dom的变动减少页面的回流和重绘 从而提高页面更新的效率 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新&lt;br&gt;diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实d</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 双向数据绑定原理</title>
    <link href="https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2019-08-16T11:09:31.000Z</published>
    <updated>2022-10-05T08:15:01.899Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法</p><p>实现一个简单的数据响应</p><pre><code>Object.defineProperty(obj,&#39;name&#39;,&#123;    get:function()&#123;        // 获取数据        return obj.name    &#125;,    set:function(val)&#123;        // 获取到新的值并且赋值给对象属性        obj.name = val    &#125;&#125;)</code></pre><p>这样就可以实现一个简单的数据响应式<br>当然这是vue2中的数据响应式<br>更新过程<br>    1. new Mvvm()   &#x2F;&#x2F; 创建一个vue实例<br>    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法<br>       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数<br>    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式</p><p>vue2 中的数据响应式的话是有缺点的<br>    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题<br>    比如 对象添加一个属性 为什么这个属性不是响应式的<br>        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性<br>    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到<br>    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式<br>vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式<br>    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象<br>    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应</p><pre><code>new Proxy(obj,&#123;    get:function(target,key,proxy)&#123;  // 三个参数  目标  属性名称  proxy实例本身        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去        return res    &#125;,    set:function(target,key,value,proxy)&#123;  // 四个参数 目标  属性名称 proxy实例本身        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去         return res    &#125;&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;b</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>null和undefined的区别</title>
    <link href="https://anshaohan.github.io/2019/06/05/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2019/06/05/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-06-05T03:05:08.000Z</published>
    <updated>2022-10-06T03:49:16.431Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法</p><p>变量被声明了，但没有赋值时，就等于undefined。<br>调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>对象没有赋值的属性，该属性的值为undefined。<br>函数没有返回值时，默认返回undefined<br>Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法</p><p>作为函数的参数，表示该函数的参数不是对象。<br>作为对象原型链的终点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法&lt;/p&gt;
&lt;p&gt;变量被声明了，但没有赋值时，就等于undefined。&lt;br&gt;调用函数时，应该提供的参数</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>css选择器有哪些？优先级？哪些属性可以继承?</title>
    <link href="https://anshaohan.github.io/2019/05/06/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF/"/>
    <id>https://anshaohan.github.io/2019/05/06/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF/</id>
    <published>2019-05-06T01:48:12.000Z</published>
    <updated>2022-10-06T01:49:47.187Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>选择器：</p><p>​id选择器、类选择器、标签选择器、后代选择器、子选择器、相邻同胞选择器、群组选择器、</p><p>​还有一些不常用的选择器：</p><p>​伪类选择器、伪元素选择器，属性选择器</p><p>​css3 中新增的选择器：</p><p>​层次选择器，伪类选择器 （新增属性）、属性选择器（新增属性）</p><p>​优先级：</p><p>​！important  &gt; 内联&gt;类选择器&gt;标签选择器</p><p>​继承属性：</p><p>​字体系列属性：</p><p>​font  </p><p>​font-family  规定元素的字体系列</p><p>​font-weight 设置字体的粗细</p><p>​font-size 设置字体的尺寸</p><p>​font-style 定义字体的风格</p><p>​font-variant 偏大或偏小的字体</p><p>​文本系列属性</p><p>​text-indent 文本缩进</p><p>​text-align 文本水平对刘</p><p>​line-height 行高</p><p>​word-spacing 增加或减少单词见的空白</p><p>​letter-spacing 增加或减少字符间的空白</p><p>​text-transform 控制文本大小写</p><p>​direction 规定文本的书写方向</p><p>​color 文本颜色</p><p>​元素可见性  visibility </p><p>​表格布局属性</p><p>​caption-side 定位表格标题位置</p><p>​border-collapse 合并表格边框</p><p>​border-spacing 设置相邻单元格的边框间的距离</p><p>​empty-cells 单元格的边框的出现与消失</p><p>​table-layout 表格的宽度由什么决定</p><p>​列表属性</p><p>​list-style-type 文字前面的小点点样式</p><p>​list-style-position 小点点位置</p><p>​ list-style 以上的属性可以通过这个属性集合</p><p>​引用 qoutes 设置嵌套引用的引号类型</p><p>​光标属性 cursor 箭头可以变成需要的形状</p><p>​继承中比较特殊的几点</p><p>​a标签的字体颜色不能被继承</p><p>​h1-h6的字体大小也是不能被继承的</p><p>​无继承的属性</p><p>​dispaly</p><p>​文本属性 vertical-align、text-decoration</p><p>​盒子模型属性 宽度 高度 内外边距 边框</p><p>​背景属性 背景图片 颜色 位置</p><p>​定位属性  浮动 清楚浮动  定位position 等</p><p>​生成内容属性 content couter-reset  counter-increment</p><p>​轮廓样式属性 outline-style </p><p>​页面样式属性 size  page-break-before  page-break-after</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;选择器：&lt;/p&gt;
&lt;p&gt;​							id选择器、类选择器、标签选择器、后代选择器、子选择器、相邻同胞选择器、群组选择器、&lt;/p&gt;
&lt;p&gt;​				还有一些不常用的选择器：					&lt;/p&gt;
&lt;p&gt;​						伪类选择器、</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>回流和重绘</title>
    <link href="https://anshaohan.github.io/2019/04/06/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <id>https://anshaohan.github.io/2019/04/06/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</id>
    <published>2019-04-06T02:08:10.000Z</published>
    <updated>2022-10-06T02:25:31.535Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>html中每个元素都可以理解为一个盒子 在浏览器解析过程中会涉及到回流与重绘：</p><p>​回流：</p><p>​布局引擎根据各种样式计算每个盒子再页面上大小与位置</p><p>​重绘：  </p><p>​当计算好盒子模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p><p>​回流触发机制：</p><p>​回流主要式计算节点的位置和几何信息，当页面布局和几何信息发生变化的时候就会触发回流</p><p>​删除或者添加可见的dom元素</p><p>​元素的位置发生变化、元素的尺寸发生变化</p><p>​内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</p><p>​页面一开始渲染的时候（这避免不了）</p><p>​浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</p><p>​重绘触发机制：</p><p>​触发回流一定会触发重绘</p><p>​颜色的修改</p><p>​文本方向的修改</p><p>​阴影的修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;html中每个元素都可以理解为一个盒子 在浏览器解析过程中会涉及到回流与重绘：&lt;/p&gt;
&lt;p&gt;​								回流：&lt;/p&gt;
&lt;p&gt;​									布局引擎根据各种样式计算每个盒子再页面上大小与位置&lt;/p&gt;
&lt;p&gt;​		</summary>
      
    
    
    
    <category term="HTML" scheme="https://anshaohan.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://anshaohan.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://anshaohan.github.io/2019/02/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://anshaohan.github.io/2019/02/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2019-02-20T02:08:13.000Z</published>
    <updated>2022-10-05T14:15:44.013Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。</p><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含</p><p>JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。<br>CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。<br>资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。</p><p>通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件。</p><h5 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h5><p>正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。规范化指的是我们在工程开发初期以及开发期间制定的系列规范，其中又包含了</p><p>项目目录结构<br>编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。<br>联调规范<br>文件命名规范<br>样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。<br>git flow 工作流：其中包含分支命名规范、代码合并规范等。<br>定期 code review … 等等</p><h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><p>从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些只是前端自动化其中的一部分，前端自动化还包含了持续集成、自动化测试等方方面面。</p><p>以上就是我所了解的前端工程化，以工程的角度去理解我们的web前端。工程是工程，而不是某项技术。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。&lt;/p&gt;
&lt;h5 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h5&gt;&lt;p</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>Css盒子模型</title>
    <link href="https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://anshaohan.github.io/2019/02/16/Css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-02-16T11:09:31.000Z</published>
    <updated>2022-10-05T06:11:58.272Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框）</li></ul><p>盒子总宽度 &#x3D; width + padding + border + margin;</p><p>盒子总高度 &#x3D; height + padding + border + margin</p><p> 也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值 </p><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin</li></ul><p>盒子总宽度 &#x3D; width + margin;</p><p>盒子总高度 &#x3D; height + margin;</p><p> 也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border</code>值 </p><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><ul><li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致</li><li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li><li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;标准盒子模型： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;content（内容）&lt;/li&gt;
&lt;li&gt;margin（外边距） ：盒子与盒子之间的距离。&lt;/li&gt;
&lt;li&gt;padding（内边距）：内容与边框的距离。&lt;/li&gt;
&lt;li&gt;bord</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>new操作符具体干了什么</title>
    <link href="https://anshaohan.github.io/2019/02/06/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://anshaohan.github.io/2019/02/06/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2019-02-06T02:33:26.000Z</published>
    <updated>2022-10-06T02:36:08.270Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>new操作符概念 在js中用于给定构造函数创建实例对象</p><p>流程<br>    创建一个新的历史对象 obj<br>    将新的实例对象obj绑定到构造函数的原型链上<br>    新的实例对象继承构造函数的this<br>    最后返回一个新对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;new操作符概念 在js中用于给定构造函数创建实例对象&lt;/p&gt;
&lt;p&gt;流程&lt;br&gt;    创建一个新的历史对象 obj&lt;br&gt;    将新的实例对象obj绑定到构造函数的原型链上&lt;br&gt;    新的实例对象继承构造函数的thi</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="https://anshaohan.github.io/2018/12/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://anshaohan.github.io/2018/12/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2018-12-05T14:16:51.000Z</published>
    <updated>2022-10-05T14:25:41.609Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>浅拷贝简单来说 拷贝的是对象再栈中的值 或者引用数据类型的指向内存空间<br>也就是说 浅拷贝的基本数据类型不会互相影响  但是引用数据类型就会进行一个互相影响 源对象发生变化之后 拷贝对象也会跟着变化</p><p>深拷贝就是 拷贝的是对象的整体 并且返回一个新的对象 并且新对象是新开辟一个内存空间 两个对象之间并不会互相影响</p><p>实现深拷贝的一些方法</p><p>循环递归</p><p>function deepclone(obj) {<br>      &#x2F;&#x2F; 判断是什么类型的数据<br>      if (typeof obj !&#x3D;&#x3D; “object” || obj &#x3D;&#x3D; null) return obj;<br>      &#x2F;&#x2F; 定义复制对象<br>      let copy &#x3D; {};<br>      &#x2F;&#x2F; 如果传入的是数组则copy定义为数组<br>      if(obj.constructor&#x3D;&#x3D;Array){<br>        copy &#x3D; []<br>      }<br>      for (key in obj) {<br>        console.log(obj[key]);<br>        &#x2F;&#x2F; deepclone(arr[i])<br>        copy[key] &#x3D; deepclone(obj[key])<br>      }<br>      return copy<br>    }</p><p>使用 JSON 中的  stringfiy 和 parse 方法 来将 对象进行解析成json字符串 然后再解析回来 就可以实现一个深拷贝对象</p><p>使用 loadsh第三方库中的 deepclone 这个方法就可以实现对象的深拷贝</p><p>需要注意的是 es6新增的一个 扩展运算符  当对象是仅一层的时候是 一个深拷贝  超过一层之后就是浅拷贝<br>和扩展运算符差不多的是 object中的 assign这个 方法 也是仅一层时是深拷贝 超过一层就是浅拷贝</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;浅拷贝简单来说 拷贝的是对象再栈中的值 或者引用数据类型的指向内存空间&lt;br&gt;也就是说 浅拷贝的基本数据类型不会互相影响  但是引用数据类型就会进行一个互相影响 源对象发生变化之后 拷贝对象也会跟着变化&lt;/p&gt;
&lt;p&gt;深拷贝</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>水平居中的方法</title>
    <link href="https://anshaohan.github.io/2018/10/10/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://anshaohan.github.io/2018/10/10/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2018-10-10T00:35:46.000Z</published>
    <updated>2022-10-05T23:48:48.570Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>实现居中方法分为两大类</p><p>​居中元素的宽高已知</p><p>​居中元素宽高未知</p><p>​实现方式</p><h3 id="​利用定位-margin-auto"><a href="#​利用定位-margin-auto" class="headerlink" title="​利用定位+margin:auto"></a>​利用定位+margin:auto</h3><style>    .father{        width:500px;        height:300px;        border:1px solid #0a3b98;        position: relative;    }    .son{        width:100px;        height:40px;        background: #f0a238;        position: absolute;        top:0;        left:0;        right:0;        bottom:0;        margin:auto;    }</style><p>父级设置为相对定位 子级绝对定位 并且4个定位属性的值都设置了0<br>如果子级没有设置宽高则会被拉开到和父级一样的宽高</p><h3 id="利用定位-margin-负值"><a href="#利用定位-margin-负值" class="headerlink" title="利用定位+margin:负值"></a>利用定位+margin:负值</h3><style>    .father {        position: relative;        width: 200px;        height: 200px;        background: skyblue;    }    .son {        position: absolute;        top: 50%;        left: 50%;        margin-left:-50px;        margin-top:-50px;        width: 100px;        height: 100px;        background: red;    }</style><h3 id="利用定位-transfrom"><a href="#利用定位-transfrom" class="headerlink" title="利用定位+transfrom"></a>利用定位+transfrom</h3><style>    .father {        position: relative;        width: 200px;        height: 200px;        background: skyblue;    }    .son {        position: absolute;        top: 50%;        left: 50%;  transform: translate(-50%,-50%);        width: 100px;        height: 100px;        background: red;    }</style><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><style>    .father {        display: table-cell;        width: 200px;        height: 200px;        background: skyblue;        vertical-align: middle;        text-align: center;    }    .son {        display: inline-block;        width: 100px;        height: 100px;        background: red;    }</style><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><style>    .father {        display: flex;        justify-content: center;        align-items: center;        width: 200px;        height: 200px;        background: skyblue;    }    .son {        width: 100px;        height: 100px;        background: red;    }</style><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><style>    .father {            display: grid;            align-items:center;            justify-content: center;            width: 200px;            height: 200px;            background: skyblue;        }        .son {            width: 10px;            height: 10px;            border: 1px solid red        }</style>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;实现居中方法分为两大类&lt;/p&gt;
&lt;p&gt;​		居中元素的宽高已知&lt;/p&gt;
&lt;p&gt;​		居中元素宽高未知&lt;/p&gt;
&lt;p&gt;​		实现方式&lt;/p&gt;
&lt;h3 id=&quot;​利用定位-margin-auto&quot;&gt;&lt;a href=&quot;#​利用定位-</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>webpack 类似的打包工具有哪些？</title>
    <link href="https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2018/10/05/webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-10-05T01:32:19.000Z</published>
    <updated>2022-10-05T06:11:53.222Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多</p><p>​优点  代码更简洁  效率更高   默认支持 tree-shaking</p><p>​缺点就是 加载其他类型的资源文件或者是导入commonjs模块</p><p>​编译es新特性等等一些需求需要使用插件来完成 会使开发效率降低</p><p>​但是在打包js库时 rollup比webpack更有优势  打包代码更小更快</p><p>​parcel  </p><p>​相比于webpack来说用法更简单 支持自动安装依赖，并且不需要配置什么，因为时多线程所以构建速度也会比webpack快，但是无法向webpack一样配置对应的loader</p><p>​snowpack</p><p>​每次保存单个文件时 为应用程序每个文件构建一次，就可以永久缓存 文件更改时 snowpack 会重新构建该文件</p><p>​Vite</p><p>​是一种新型前端构建工具 能显著的提升前端开发体验</p><p>​两部分组成</p><p>​一个开发服务器</p><p>​一套构建指令  使用rollup 来打包你的代码  并且不需要自己配置</p><p>​就可以输出用于生产环境的优化过的静态资源</p><p>​快速的冷启动 、即时的模块热更新 真正的按需编译</p><p>​vite会直接启动开发服务器 不需要进行打包操作 也就意味着不需要分析 模块之间的依赖 不需要编译 所以启动速度很快</p><p>​当修改一个模块时只需要然浏览器重新请求这个模块 不需要像webpack那样需要把该模块的相关依赖全部编译 效率相对来说更高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	rollup   是一个 es modules 的打包工具 从作用上看 和webpack差不多  但是要比webpack小巧很多&lt;/p&gt;
&lt;p&gt;​			优点  代码更简洁  效率更高   默认支持 tree-shaking</summary>
      
    
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/categories/webpack/"/>
    
    
    <category term="webpack" scheme="https://anshaohan.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>说说JavaScript中的数据类型</title>
    <link href="https://anshaohan.github.io/2018/09/06/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://anshaohan.github.io/2018/09/06/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2018-09-06T01:50:04.000Z</published>
    <updated>2022-10-06T01:51:40.902Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>js中的数据类型分为两种 基本数据类型 和 引用数据类型<br>两种类型的区别是:储存位置不同</p><p>​基本类型:</p><p>​Number,String,Boolean,Undefined,null,symbol</p><p>​引用数据类型:</p><p>​统称为Object ,</p><p>​Object,Array,Function,Date,RegExp,Map,Set等</p><p>​存储区别:</p><p>​基本数据类型存储在栈中,</p><p>​引用类型的对象储存于堆中,</p><p>​当变量赋值时,解析器首先要确认的就是这个值是基本类型值还是引用类型值</p><p>​声明变量时不同的内存地址分配:</p><p>​简单类型的值存放在栈中,在栈中存放的时对应的值</p><p>​引用类型对应的值存储在堆中,在栈中存放的是指向堆内存的地址</p><p>​不同的类型数据导致赋值变量时的不同:</p><p>​简单类型赋值,是生成相同的值,两个对象不同的地址</p><p>​复杂类型赋值,是将保存对象的内存地址赋值给另一个变量,也就是两个变量指向堆内存中同一个对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;js中的数据类型分为两种 基本数据类型 和 引用数据类型&lt;br&gt;两种类型的区别是:储存位置不同&lt;/p&gt;
&lt;p&gt;​				基本类型:&lt;/p&gt;
&lt;p&gt;​						Number,String,Boolean,Undefined,</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://anshaohan.github.io/2018/07/05/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2018-07-05T03:33:50.000Z</published>
    <updated>2022-10-05T11:07:07.820Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>  防抖和节流简单来说就是个可以处理高频率请求的一种手段</p><pre><code>    防抖         函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。    节流        函数在n秒内执行,如果在n秒内又重复执行该函数,则不会重复执行,直到计时完毕然后运行一次请求。    区别        防抖是在一段时间内如果重复多次的请求 那么只会执行最后一次  相对的场景 比如搜索框  当我们输入完毕之后才会发送请求而不是变一下就会发送一个请求        节流是在一段时间内如果重复多次的请求 那么只会执行最后一次 相对的场景  比如监听滚动条然后让图片进行懒加载     相同点        都可以使用setTimeout 进行实现  目的相同 降低回调 节省计算成本    主要应用场景         防抖             a、scroll事件滚动触发，            b、搜索框输入查询            c、表单验证            d、按钮提交事件            e、浏览器窗口缩放，resize事件        节流            a、DOM元素的拖拽功能实现            b、射击游戏类            c、计算鼠标移动的距离            d、监听scroll事件    防抖实现        function F(fn)&#123;  // 防抖函数            let timeout   // 定义一个参数获取时间            return function()&#123;                clearTimeout(timeout)                timeout = setTimeout(()=&gt;&#123;  // 定义定时器 500毫秒的间隔                     fn.apply(this,arguments)                 &#125;,500)            &#125;        &#125;        每次调用 F 函数 都会清除之前的timeout  并且返回一个新的timeout setTimeout 设置的时间结束后才会运行原本的函数，这样就是一个简单的函数防抖实现    节流实现   有两种方法可以实现  定时器  或者 时间戳的方式        function J(fn, wait)&#123;           // 时间戳版            let previous = 0;            return function () &#123;                let now = new Date();                if (now - previous &gt; wait) &#123;                    previous = now;                    func.apply(this, arguments)                &#125;            &#125;        &#125;        定义时间戳然后返回一个函数 函数内部声明一个执行时的时间戳 然后进行判断 当前时间减去定义的时间戳如果大于传入的等待时间那就把定义的时间戳赋值到刚刚创建的新的时间戳 并且执行函数         function J(fn, wait) &#123;            // 定时器版            let timer;            return function () &#123;                let context = this;                if (!timer) &#123;                    timer = setTimeout(() =&gt; &#123;                        timer = null;                        func.apply(context, arguments)                    &#125;, wait)                &#125;            &#125;        &#125;        定时器版本 就是增加一个setTimeout实现  定义一个空变量 然后 返回函数 函数中获取到当前的this 然后进行判断这个定义的变量是否存在 不存在就时false 然后取反值 然后将setTimeout 赋值给定义的变量然后再定时器内部将这个变量释放 并且执行传入的函数</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;  防抖和节流简单来说就是个可以处理高频率请求的一种手段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    防抖 
        函数在n秒内执行,如果在n秒内又重复执行该函数,那么就会重新计时，直到计时完毕然后运行最后一次请求。
  </summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
</feed>
