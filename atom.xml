<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://anshaohan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anshaohan.github.io/"/>
  <updated>2022-10-09T03:22:44.936Z</updated>
  <id>https://anshaohan.github.io/</id>
  
  <author>
    <name>AnShaoHan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流式布局</title>
    <link href="https://anshaohan.github.io/2022/10/25/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://anshaohan.github.io/2022/10/25/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</id>
    <published>2022-10-25T03:21:11.000Z</published>
    <updated>2022-10-09T03:22:44.936Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>如何通过js判断一个数组</title>
    <link href="https://anshaohan.github.io/2022/10/06/%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/"/>
    <id>https://anshaohan.github.io/2022/10/06/%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</id>
    <published>2022-10-06T02:28:03.000Z</published>
    <updated>2022-10-06T02:28:33.156Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​<strong>通过原型链判断</strong></p><p>​__ proto __</p><p>​实例的__ proto__属性指向其构造函数的原型对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​constructor</p><p>​实例的constructor属性指向构造函数本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">constructor</span> === <span class="title class_">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​instanceof</p><p>​instanceof可以判断Array是否是实例的构造函数（在原型链上即可）</p><p>​isPrototypeOf()</p><p>​判断Array的原型对象是否为在某个对象的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(arr) )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​通过Object原型上的方法判断</p><p>​Array.isArray()</p><p>​es6中用于判断数组类型的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​Object.prototype.toString</p><p>​Object原型对象上的方法，被所有对象继承，返回<code>&#39;[Object type]&#39;</code>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr))  <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	&lt;strong&gt;通过原型链判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​						__ proto __&lt;/p&gt;
&lt;p&gt;​								实例的__ proto__属性指向其构造函数的原型对象.&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>什么是响应式设计</title>
    <link href="https://anshaohan.github.io/2021/08/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://anshaohan.github.io/2021/08/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-08-16T02:08:50.000Z</published>
    <updated>2022-10-06T02:24:34.901Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>响应式设计是一种网络页面设计布局 页面的开发和设计 应该根据用户的行为和设备大小 来做出相应的响应和调整</p><p>​响应式网站常见的特点：</p><p>​同时适配pc+平板+手机等</p><p>​标签导航在接近手持终端设备时改变为经典的抽屉式导航</p><p>​网站的布局会根据视口来调整模块的大小和位置</p><p>​实现方式</p><p>​原理  通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport</p><p>​实现响应式布局方式</p><p>​媒体查询</p><p>​给不同分辨率的设备编写不同的样式来实现响应式布局，可以给不同分辨率的屏幕设置不同的样式</p><p>​百分比</p><p>​通过百分比单位来实现响应式的效果</p><p>​可以让组件随着浏览器的宽度和高度变化而变化从而实现响应式布局，有些元素并不继承父元素的尺寸 所以并不建议使用百分比实现响应式</p><p>​vw&#x2F;vh</p><p>​vw表示相对于视图窗口的宽度，vh表示相对于视图窗口的高度，任意层级元素，在使用vw单位的情况下。1vw都等于视图宽度的百分之一</p><p>​rem</p><p>​rem 相当于根元素html的font-size属性，默认浏览器字体大小为16px 所以 1rem &#x3D; 16px</p><p>​还可以利用ui框架 的栅格布局实现响应式</p><p>​响应式设计通常会从以下几个方面思考：</p><p>​弹性盒子 和媒体查询等技术</p><p>​使用百分比布局创建流式布局的弹性ui同时使用媒体查询限制元素的尺寸和内容变更范围</p><p>​使用相对单位使得内容自适应调节</p><p>​选择断点针对不同断点实现不同的布局和内容展示</p><p>​总结</p><p>​响应式布局的优点</p><p>​面对不同分辨率设备灵活性强</p><p>​能够快捷解决多设备显示适应问题</p><p>​缺点</p><p>​仅适用布局、信息、框架、并不复杂的部门类型网站</p><p>​兼容各种设备工作量大，效率低下</p><p>​代码累赘，会出现隐藏无用的元素，加载时间加长</p><p>​一种折中性的设计解决方案，多方面因素影响而达不到最佳效果，</p><p>​一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;响应式设计是一种网络页面设计布局 页面的开发和设计 应该根据用户的行为和设备大小 来做出相应的响应和调整&lt;/p&gt;
&lt;p&gt;​						响应式网站常见的特点：&lt;/p&gt;
&lt;p&gt;​									同时适配pc+平板+手机等&lt;/p&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>说说React生命周期有哪些不同阶段？每个阶段对应的方法是？</title>
    <link href="https://anshaohan.github.io/2021/05/09/%E8%AF%B4%E8%AF%B4React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%EF%BC%9F%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2021/05/09/%E8%AF%B4%E8%AF%B4React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%EF%BC%9F%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%9F/</id>
    <published>2021-05-09T02:51:12.000Z</published>
    <updated>2022-10-09T02:53:11.737Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​react生命周期分为3个阶段</p><p>​创建阶段</p><p>​更新阶段</p><p>​卸载阶段</p><p>​创建阶段主要分成了以下几个生命周期方法：</p><p>​constructor  构造函数</p><p>实例过程中自动调用的方法，在方法内部通过super关键字获取来自父组件的props</p><p>在该方法中，通常的操作为初始化state状态或者在this上挂载方法</p><p>​getDerivedStateFromProps</p><p>​render</p><p>​类组件必须实现的方法，用于渲染DOM结构，可以访问组件state与prop属性</p><p>​componentDidMount</p><p>​组件挂载到真实DOM节点后执行，其在render方法之后执行</p><p>此方法多用于执行一些数据获取，事件监听等操作</p><p>​更新阶段的函数主要为如下方法：</p><p>​getDerivedStateFromProps</p><p>​shouldComponentUpdate</p><p>​render</p><p>​getSnapshotBeforeUpdate</p><p>​componentDidUpdate</p><p>​卸载阶段</p><p>​<strong>componentWillUnmount</strong></p><p>此方法用于组件卸载前，清理一些注册监听事件，或者取消订阅的网络请求等</p><p>一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;​	react生命周期分为3个阶段&lt;/p&gt;
&lt;p&gt;​													创建阶段&lt;/p&gt;
&lt;p&gt;​													更新阶段&lt;/p&gt;
&lt;p&gt;​													卸载阶段&lt;/p&gt;
&lt;p&gt;​								</summary>
      
    
    
    
    <category term="React" scheme="https://anshaohan.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://anshaohan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>说说你对发布订阅、观察者模式的理解？区别？</title>
    <link href="https://anshaohan.github.io/2020/12/09/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://anshaohan.github.io/2020/12/09/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2020-12-09T02:53:19.000Z</published>
    <updated>2022-10-09T02:55:35.642Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​<strong>观察者模式</strong></p><p>​观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p><p>​观察者模式一般至少有一个可被观察的对象 Subject ，可以有多个<code>观察者</code>去观察这个对象。二者的关系是通过<code>被观察者主动</code>建立的，<code>被观察者</code>至少要有三个方法——添加观察者、移除观察者、通知观察者。</p><p>​当被观察者将某个观察者添加到自己的<code>观察者列表</code>后，观察者与被观察者的关联就建立起来了。此后只要被观察者在某种时机触发<code>通知观察者</code>方法时，观察者即可接收到来自被观察者的消息</p><p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p><p>​<strong>发布订阅模式</strong></p><p>​发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p><p>​与<code>观察者模式</code>相比，发布订阅核心基于一个中心来建立整个体系。其中<code>发布者</code>和<code>订阅者</code>不直接进行通信，而是发布者将要发布的消息交由中心管理，订阅者也是根据自己的情况，按需订阅中心中的消息。</p><p>​<strong>区别</strong></p><p>​观察者是经典软件<code>设计模式</code>中的一种，但发布订阅只是软件架构中的一种<code>消息范式</code>。</p><p>​实现二者所需的角色数量有着明显的区别。观察者模式本身只需要<code>2个</code>角色便可成型，即<code>观察者</code>和<code>被观察者</code>，其中<code>被观察者</code>是重点。而发布订阅需要至少<code>3个</code>角色来组成，包括<code>发布者</code>、<code>订阅者</code>和<code>发布订阅中心</code>，其中<code>发布订阅中心</code>是重点。</p><p>​观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p><p>​在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</p><p>​观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	&lt;strong&gt;观察者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​							观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新&lt;/p&gt;
&lt;p&gt;​						</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>Token cookie session 区别</title>
    <link href="https://anshaohan.github.io/2020/11/09/Token-cookie-session-%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/11/09/Token-cookie-session-%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-09T02:53:40.000Z</published>
    <updated>2022-10-09T02:54:26.062Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>Cookie</strong>：</p><p>​cookie网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据(通常经过加密)，发送请求时，cookie会随着请求头一起发给服务器， cookie储存于浏览器</p><p>​作用：识别用户信息，储存用户数据</p><p>​cookie具有时效性，存活时间取决于不同的网站，在cookie未失效时，若再次登录该网站，则会自动登录，不需要重新输入账号与密码</p><p><strong>Session</strong>:<br>            session是服务器为了保存用户状态而创建的一个特殊的对象。session储存在服务器</p><p>​当用户第一次登陆网站时，服务器会生成一个session，并将该sessionID发送给用户储存在cookie中，当第二次发送请求时，sessionID就随着cookie一起发送，浏览器就可以识别出是谁发送的请求</p><p>当用户离开网站时，储存的session会被销毁</p><p><strong>Token</strong>：<br>            Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>​作用机制：服务器并不保存token，而是通过数据签名的方法，对数据用算法（如SHA-256）与私钥进行签名后作为Token，当Token发送给服务器时，服务会通过相同的算法与密钥进行签名，如果和Token中的签名相同，服务器就知道用户已经登录过了，并且可以直接得到用户的userID</p><p><strong>1.session和cookie区别：</strong></p><pre><code>                             数据存放位置不同：Session数据是存在服务器中的，cookie数据存放在浏览器当中。                              安全程度不同：cookie放在服务器中不是很安全，session放在服务器中，相对安全。</code></pre><p>​性能使用程度不同：session放在服务器上，访问增多会占用服务器的性能；考虑到减轻服务器性能方面，应使用cookie。</p><p>​数据存储大小不同：单个cookie保存的数据不能超过4K，session存储在服务端，根据服务器大小来定。</p><p>​</p><p><strong>2.token和session区别：</strong></p><p>​token是开发定义的，session是http协议规定的；</p><p>​ token不一定存储，session存在服务器中；</p><p>​ token可以跨域，session不可以跨域，它是与域名绑定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;​			cookie网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据(通常经过加密)，发送请求时，cookie会随着请求头一起发给服务</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>js中变量提升</title>
    <link href="https://anshaohan.github.io/2020/11/06/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://anshaohan.github.io/2020/11/06/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2020-11-06T03:05:26.000Z</published>
    <updated>2022-10-07T10:22:41.069Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>js中变量提升概念<br>    在js中如果我们进行先调用 后声明赋值的方式进行使用变量 js中的变量提升就会展现出来<br>    当我们先调用这个变量的时候   这个变量隐式的声明 并且赋值为undefined<br>    然后当我们在下面调用这个变量进行赋值时 就会盖过undefined 变成赋值的那个值</p><pre><code>console.log(num)  //这时会打印出 undefinedvar num = 123 //  这是个赋值过程console.log(num) // 打印 123需要注意的是 变量提升只能使用 var  定义  使用es6新增的let  const的话会之间报错关于变量提升的概念 还有函数提升 并且函数提升的优先级要比变量提升高b()function b()&#123;    console.log(&#39;frist&#39;)&#125;function b()&#123;    console.log(&#39;第二&#39;)&#125;var b = 1最后打印结果是 第二</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;js中变量提升概念&lt;br&gt;    在js中如果我们进行先调用 后声明赋值的方式进行使用变量 js中的变量提升就会展现出来&lt;br&gt;    当我们先调用这个变量的时候   这个变量隐式的声明 并且赋值为undefined&lt;br&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>双飞翼布局</title>
    <link href="https://anshaohan.github.io/2020/10/20/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>https://anshaohan.github.io/2020/10/20/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</id>
    <published>2020-10-20T03:20:49.000Z</published>
    <updated>2022-10-09T03:22:26.710Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局</title>
    <link href="https://anshaohan.github.io/2020/10/09/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>https://anshaohan.github.io/2020/10/09/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</id>
    <published>2020-10-09T03:20:59.000Z</published>
    <updated>2022-10-09T03:22:12.692Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>BFC布局</title>
    <link href="https://anshaohan.github.io/2020/09/06/BFC/"/>
    <id>https://anshaohan.github.io/2020/09/06/BFC/</id>
    <published>2020-09-06T06:32:46.000Z</published>
    <updated>2022-10-06T06:56:15.653Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>官方定义：BFC（Block Formatting Context）块格式化上下文， 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。<br>简单来说 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素<br>BFC的应用<br>    1、自适应两栏布局<br>    2、清除内部浮动<br>    3、防止margin上下重叠</p><p>BFC的布局规则<br>    1、内部的Box会在垂直方向，一个接一个地放置。<br>    2、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置）<br>    3、每个元素的margin box的左边， 与包含块border box的左边相接触<br>    4、BFC的区域不会与float box重叠。<br>    5、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>    6、计算BFC的高度时，浮动元素也参与计算</p><p>如何创建一个BFC<br>    使用浮动元素 给盒子设置 float  left 或者 right 就可以打开BFC<br>    使用定位 position  设置 absolute绝对定位 或者 fixed 固定定位<br>    display 设置为 inline-block  table-cell flex inline-flex  table-caption<br>    overflow 不为visible</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;官方定义：BFC（Block Formatting Context）块格式化上下文， 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。&lt;br&gt;简单来说 BFC就是页面上的一</summary>
      
    
    
    
    <category term="Css" scheme="https://anshaohan.github.io/categories/Css/"/>
    
    
    <category term="Css" scheme="https://anshaohan.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件之间的通信方式都有哪些</title>
    <link href="https://anshaohan.github.io/2020/08/09/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>https://anshaohan.github.io/2020/08/09/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/</id>
    <published>2020-08-09T02:47:14.000Z</published>
    <updated>2022-10-09T02:50:12.431Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>vuex</p><p>​State：放状态的地方</p><p>​Mutation：唯一修改状态的地方，不支持异步</p><p>·Action：通过调用Mutation中的方法来达到修改状态的目的，支持异步</p><p>​Getter：可以理解为计算属性</p><p>​Module：模块每个模块拥有自己的 state、mutation、action、getter</p><p>​父子组件间通信</p><p>​子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据</p><p>​通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信</p><p>​vue3新增加的  使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据</p><p>​</p><p>​兄弟组件间通信</p><p>​使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递</p><p>​通过 $parent &#x2F; $refs 来获取到兄弟组件，也可以进行通信。</p><p>​任意组件间通信</p><p>​使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件</p><p>第三方库 pubsub.Js 可以实现<br>        <a href="https://github.com/mroderick/PubSubJS#readme">https://github.com/mroderick/PubSubJS#readme</a></p><pre><code>    介绍</code></pre><p>PubSubJS是一个用JavaScript编写的基于主题的 发布&#x2F;订阅库<br>PubSubJS具有同步解耦，因此主题是异步发布的。这有助于保持程序的可预测性，因为在消费者处理主题时，不会阻止主题的创建者。</p><p>安装<br>vue 使用 PubSubJS 用法:<br>npm install pubsub-js</p><p>全局引用<br>只需要在main.js 引入 import PubSub from ‘pubsub-js’</p><p>使用<br>发布:<br>PubSub.publish( id, params)</p><p>订阅:<br>PubSub.subscribe( id, function(msg, params) )<br>对指定的id进行订阅, 需要与发布方的id名保持一致, 当生产者发布一条消息, 订阅者会对此消息进行消费处理</p><p>取消订阅:<br>PubSub.unsubscribe( …id )<br>可取消多个订阅, id 用逗号隔开即可<br>可防止造成多次发布订阅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;vuex&lt;/p&gt;
&lt;p&gt;​							State：放状态的地方&lt;/p&gt;
&lt;p&gt;​							Mutation：唯一修改状态的地方，不支持异步&lt;/p&gt;
&lt;p&gt;·							Action：通过调用Mutation中的方法来达</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>typeof 与 instanceof 区别</title>
    <link href="https://anshaohan.github.io/2020/04/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/04/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/</id>
    <published>2020-04-26T11:58:04.000Z</published>
    <updated>2022-10-06T03:47:23.395Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p> typeof 只有6种返回值  number  string   Boolean  object  function undefined</p><p>​typeof 操作符返回一个字符串,表示未经计算的操作数的类型</p><p>虽然 typeof null 为 object  这是javaScript 一个悠久的Bug 不代表null 就是引用数据类型 并且null 本身也不是对象 所以 null在typeof之后返回的是有问题的结果</p><p>​instanceof  运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>​实现原理 顺着原型链去找,直到找到相同的原型对象,返回true , 否则为 false</p><p>​  typeof 与 instanceof 都是判断数据类型的方法 区别如下</p><p>​typeof 会返回一个变量的基本类型,instanceof,返回的是一个布尔值</p><p>​instanceof 可以准确地判断复杂引用数据类型,但是不能正确判断基础数据类型</p><p>​typeof 也存在弊端 虽然可以判断基础数据类型 null除外</p><p>​但是引用数据类型中,除了function 类型以外,其他的也无法判断</p><p>​如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]”</code>的字符串</p><p>typeof 的原理<br>    typeof 是根据二进制来判断的  所以之只能判断基本类型和object 但是并不能判断出是哪一种object<br>    000 对象  010 浮点数  1整数  110 布尔值 100字符串<br>    至于为什么判断null 为object  是因为null的机器码是000 所以会判断为object</p><p>instanceof 原理<br>    就是根据判断对象A是否在对象B的原型链上 如果在那么就会返回True 如果不在就返回False</p><pre><code>简单的实现一个instanceoffunction Myinstance(left,right)&#123; // 接收两个对象    let proto = Object.getPrototyepOf(left)   // 获取到对象的原型    let prototype = right.prototype  // 获取到构造函数的原型    whlie(true)&#123;        // 因为最后会获取到null null是原型的顶层 并且不是一个对象所以会报错 null转换布尔值会是false        // 而对象转换布尔值为 true          if(!proto) return false         if(proto==prototype) return true   // 判断原型和原型是否相同 是的话就返回true        // 如果当前没有找到 就重新赋值往原型链上寻找        proto = Object.getPrototyepOf(proto)    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;p&gt; typeof 只有6种返回值  number  string   Boolean  object  function undefined&lt;/p&gt;
&lt;p&gt;​							typeof 操作符返回一个字符串,表示未经计算的</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>for in 和 for of的区别</title>
    <link href="https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2020/02/05/for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-05T12:26:30.000Z</published>
    <updated>2022-10-05T14:31:07.485Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>for in  和 for of 的区别<br>    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的<br>    for in的区别<br>        for in  遍历获取的是对象的键值  而for of 遍历获取的是对象的键名<br>        for in 是遍历整个对象 还有对象的原型链<br>        for of  是只遍历 对象的值 不遍历对象的原型链<br>        对于数组的遍历<br>        for in 会返回数组的可枚举属性 包括原型链的可枚举属性<br>        for of 只会返回数组下标对应的属性值<br>        总结就是 for in 主要是为了遍历对象而生的 不适用遍历数组<br>        而for of 可以遍历数组 字符串 等等的一些仅获取值的对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;for in  和 for of 的区别&lt;br&gt;    for of 是es6 新增的 允许遍历一个 有interator接口的数据结构 与es3中的&lt;br&gt;    for in的区别&lt;br&gt;        for in  遍</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>js模块化开发是什么</title>
    <link href="https://anshaohan.github.io/2020/01/22/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://anshaohan.github.io/2020/01/22/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-01-22T03:05:51.000Z</published>
    <updated>2022-10-06T05:35:11.961Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>vue中的diff算法和虚拟dom</title>
    <link href="https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://anshaohan.github.io/2019/10/20/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2019-10-20T11:08:13.000Z</published>
    <updated>2022-10-05T11:54:07.511Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新<br>diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实dom<br>diff算法的特性就是 同级比较 深度优先<br>diff算法的原理<br>    首先会有一个 h函数 这个函数中有一个vnode方法 创建虚拟dom 并且返回出去 作用就是初始化时将根据真实dom创建一层虚拟dom<br>    当数据更新时 会创建一个新的虚拟dom 将新的虚拟dom和旧的虚拟dom 传入patch函数中并且进行对比<br>    patch相当于对比入口,对比的是根节点并且将更新操作到真实dom上<br>    patch函数中有几个方法 patchVnode 进行两个节点的子节点进行比较并且将更新操作到真实dom<br>    然后有一个 updataChildren 方法进行对比节点<br>    对比过程中会有四个指针  旧前  旧后  新前  新后 四个指针  旧节点的第一个 和最后一个节点我们称之为 旧前和旧后<br>    相同的 新的vdom 的第一个和最后一个称之为 新前 新后<br>    对比过程<br>        旧前和新前对比    旧后和新后对比  旧前和新后对比 旧后和新前对比<br>    在对比过程中如果对比两个节点相同就不会继续对比 然后继续对比剩下的 如果对比两个节点没有相似度的话就直接新增节点<br>    diff算法就是一个循环递归的过程<br>    具体源码的话可以去看一些 snabbdom 这个库 diff算法是基于这个库的<br>虚拟dom<br>    虚拟dom简单来说就是一个js对象  使用js对象的方式来描述页面的dom<br>    虚拟dom的好处 相比于真实dom 虚拟dom的创建成本比较低 并且如果中间不加一层虚拟dom直接操作真实dom的话会频繁的触发回流和重绘<br>    造成浏览器的资源浪费并且会造成页面卡顿 影响用户体验 如果有一层虚拟dom呢 如果数据更新就会先去操作虚拟dom 等待对比更新完成之后才会操作真实dom 大大的提高了浏览器的效率，真实dom的创建成本很高 哪怕是简单的一个div 也有很多的属性和方法 而虚拟dom的话就只需要最基本的方法就可以实现<br>key的作用<br>    ​key的作用就是唯一标识  在进行diff的时候对比的两个虚拟节点，会进行判断是否为相同节点  ，有了key之后 可以更加明确的判断连哥哥姐弟啊你是否为同一个虚拟节点  是的话就判断子节点是否有变更 如果不加key 的话如果两个标签名相同 就会判定为同一个节点 ，对比之后就会发现两个节点有不一样 这样就会增加很多对真实dom的操作 导致页面频繁的回流和重绘  使用key可以有效的减少真实dom的变动减少页面的回流和重绘 从而提高页面更新的效率 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;diff算法 是一种对比算法 对比的对象是 新旧虚拟dom diff算法并不仅仅是对比 还可以将对比的结果更新到真实dom上实现视图更新&lt;br&gt;diff算法的核心就是一个pacth函数 来进行对比新旧虚拟dom并且更新到真实d</summary>
      
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 双向数据绑定原理</title>
    <link href="https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://anshaohan.github.io/2019/08/16/Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2019-08-16T11:09:31.000Z</published>
    <updated>2022-10-09T03:00:45.692Z</updated>
    
    <content type="html"><![CDATA[<p>4<br>双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法</p><p>实现一个简单的数据响应</p><pre><code>Object.defineProperty(obj,&#39;name&#39;,&#123;    get:function()&#123;        // 获取数据        return obj.name    &#125;,    set:function(val)&#123;        // 获取到新的值并且赋值给对象属性        obj.name = val    &#125;&#125;)</code></pre><p>这样就可以实现一个简单的数据响应式<br>当然这是vue2中的数据响应式<br>更新过程<br>    1. new Mvvm()   &#x2F;&#x2F; 创建一个vue实例<br>    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法<br>       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数<br>    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式</p><p>vue2 中的数据响应式的话是有缺点的<br>    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题<br>    比如 对象添加一个属性 为什么这个属性不是响应式的<br>        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性<br>    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到<br>    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式<br>vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式<br>    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象<br>    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应</p><pre><code>new Proxy(obj,&#123;    get:function(target,key,proxy)&#123;  // 三个参数  目标  属性名称  proxy实例本身        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去        return res    &#125;,    set:function(target,key,value,proxy)&#123;  // 四个参数 目标  属性名称 proxy实例本身        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去         return res    &#125;&#125;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;4&lt;br&gt;双向数据绑定的原理：采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;br&gt;其中 数据劫持就是使用 object.defineProperty 来实现 对data中的数据进行循环绑定 每个属性身上都会有一个 getter 和 setter方法&lt;/p&gt;
&lt;p&gt;实现一个简单的数据响应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.defineProperty(obj,&amp;#39;name&amp;#39;,&amp;#123;
    get:function()&amp;#123;
        // 获取数据
        return obj.name
    &amp;#125;,
    set:function(val)&amp;#123;
        // 获取到新的值并且赋值给对象属性
        obj.name = val
    &amp;#125;
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以实现一个简单的数据响应式&lt;br&gt;当然这是vue2中的数据响应式&lt;br&gt;更新过程&lt;br&gt;    1. new Mvvm()   &amp;#x2F;&amp;#x2F; 创建一个vue实例&lt;br&gt;    2. 同时两个对象进行编译  observer对象 来遍历data中的数据给data中的每一项数据都绑定一个getter 和setter方法&lt;br&gt;       compile 对象进行编译模板 然后进行初始化视图 和 绑定订阅者然后订阅数据变化 并且绑定更新函数&lt;br&gt;    3. wacther对象 是一个依赖收集的作用 每个属性身上都会有一个dep对象 当数据发生变化之后 dep会通知wecther去派发更新调用update方法 来实现数据的响应式&lt;/p&gt;
&lt;p&gt;vue2 中的数据响应式的话是有缺点的&lt;br&gt;    首先 vue2中的数据响应式监听不到对 对象的操作  删除 添加 因为监听的是对象的属性而不是对象 然后就会有一些问题&lt;br&gt;    比如 对象添加一个属性 为什么这个属性不是响应式的&lt;br&gt;        那是因为vue的数据劫持是在初始化时 绑定到我们的属性 你去新增一个对象属性 1是监听不到对象的变化 2是 属性身上并没有getter 和 setter属性&lt;br&gt;    第二点就是  对于数组的一个监听  同理 监听的是对象的属性  数组的话也是引用数据类型 并且如果使用数组下标去操作数组 也是监听不到的 但是使用数组身上的方法就可以被监听到&lt;br&gt;    相对于对象来说 怎么去解决   vue2中也是有相应的一个api  $set $delete 等等一些方法去操作对象 就可以实现对象的响应式&lt;br&gt;vue3 中的响应式是根据 es6新增的Proxy 构造函数 有代理的意思结合新增的 Reflect  数据反射来实现的数据响应式&lt;br&gt;    概念就是 在目标对象前增加一层拦截  访问对象都会经过这层拦截 可以对外部访问进行过滤和改写  并且返回一个新的对象&lt;br&gt;    vue3中的响应式监听的是对象本身 而不是一个属性  所以当我们对 对象进行操作时都可以被监听到并且实现数据响应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Proxy(obj,&amp;#123;
    get:function(target,key,proxy)&amp;#123;  // 三个参数  目标  属性名称  proxy实例本身
        const res = Reflect.get(target,key,proxy) // 通过Reflect 反射出去
        return res
    &amp;#125;,
    set:function(target,key,value,proxy)&amp;#123;  // 四个参数 目标  属性名称 proxy实例本身
        const res = Reflect.get(target,key，value,proxy) // 通过Reflect 更新新的值 反射出去 
        return res
    &amp;#125;
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://anshaohan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>说说 git 发生冲突的场景？如何解决</title>
    <link href="https://anshaohan.github.io/2019/07/09/%E8%AF%B4%E8%AF%B4-git-%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>https://anshaohan.github.io/2019/07/09/%E8%AF%B4%E8%AF%B4-git-%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</id>
    <published>2019-07-09T10:00:53.000Z</published>
    <updated>2022-10-09T03:01:25.106Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​一般情况下，出现冲突的场景有如下：</p><p>​多个分支代码合并到一个分支时</p><p>​多个分支向同一个远端分支推送</p><p>​具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p><p>​冲突解决方法</p><p>​情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit。</p><p>​情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</p><p>​现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，<code>Git</code>就会将它们标记为冲突已解决</p><p>​当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p><p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们期望的内容，再提交    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	一般情况下，出现冲突的场景有如下：&lt;/p&gt;
&lt;p&gt;​										多个分支代码合并到一个分支时&lt;/p&gt;
&lt;p&gt;​										多个分支向同一个远端分支推送&lt;/p&gt;
&lt;p&gt;​							具体情况就是，多个分支修</summary>
      
    
    
    
    <category term="Git" scheme="https://anshaohan.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://anshaohan.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://anshaohan.github.io/2019/06/09/%E9%97%AD%E5%8C%85/"/>
    <id>https://anshaohan.github.io/2019/06/09/%E9%97%AD%E5%8C%85/</id>
    <published>2019-06-09T11:20:35.000Z</published>
    <updated>2022-10-09T03:21:36.937Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>null和undefined的区别</title>
    <link href="https://anshaohan.github.io/2019/06/05/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://anshaohan.github.io/2019/06/05/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-06-05T03:05:08.000Z</published>
    <updated>2022-10-06T03:49:16.431Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法</p><p>变量被声明了，但没有赋值时，就等于undefined。<br>调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>对象没有赋值的属性，该属性的值为undefined。<br>函数没有返回值时，默认返回undefined<br>Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法</p><p>作为函数的参数，表示该函数的参数不是对象。<br>作为对象原型链的终点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法&lt;/p&gt;
&lt;p&gt;变量被声明了，但没有赋值时，就等于undefined。&lt;br&gt;调用函数时，应该提供的参数</summary>
      
    
    
    
    <category term="Js" scheme="https://anshaohan.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://anshaohan.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>说说对git的理解</title>
    <link href="https://anshaohan.github.io/2019/05/16/%E8%AF%B4%E8%AF%B4%E5%AF%B9git%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://anshaohan.github.io/2019/05/16/%E8%AF%B4%E8%AF%B4%E5%AF%B9git%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2019-05-16T02:59:54.000Z</published>
    <updated>2022-10-09T03:00:24.984Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​git 是一个分布式管理版本的控制软件，其作用就是可以让你更好的管理你的程序，</p><p>​<strong>工作原理</strong></p><p>​当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p><p>​<code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p><p>​<code>Git</code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来</p><p><strong>当我们修改文件的时候，git就会修改文件的状态，可以通过git status进行查询，状态情况如下：</strong></p><p>​已修改（modified）：表示修改了文件，但还没保存到数据库中。</p><p>​已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>​已提交（committed）：表示数据已经安全的保存在本地数据库中。</p><p><strong>文件状态对应的，不同状态的文件在Git中处于不同的工作区域，主要分成了四部分：</strong></p><p>​工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</p><p>​暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</p><p>​本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</p><p>​远程仓库：远程的仓库，如 github</p><p><strong><code>git</code>日常简单的使用的6个命令：</strong></p><p>​add    commit   push   pull  clone  checkout</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;​	git 是一个分布式管理版本的控制软件，其作用就是可以让你更好的管理你的程序，&lt;/p&gt;
&lt;p&gt;​				&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​						当我们通过&lt;code&gt;git init&lt;/co</summary>
      
    
    
    
    <category term="Git" scheme="https://anshaohan.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://anshaohan.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
